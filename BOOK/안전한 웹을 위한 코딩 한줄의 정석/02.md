## 안전한 웹을 위한 코딩 한줄의 정석

```markdown
취약성이란? -> 실습 환경 -> 보안 기초 -> 취약성 패턴 및 대책 -> 대표적인 보안 기능 -> 웹 안전성을 높이기 위한 정책 -> 안전한 웹 어플리케이션 개발 프로세스
```

- <strong>취약성 패턴 및 대책</strong>

### 웹 애플리케이션 기능과 취약성

발생하기 쉬운 취약성의 종류를 크게 두가지로 구분하면 출력에 기인하는 취약성, 처리에 기인하는 취약성으로 나눌 수 있다

- 출력에 기인하는 취약성
  - 브라우저: 크로스 사이트 스크립팅, HTTP 헤더 인젝션
  - RDB:  SQL 인젝션
  - 쉘(Shell): OS 커멘드 인젝션
  - 메일: 메일 헤더 인젝션
- 처리에 기인하는 취약성
  - 파일: 디렉토리 접근 공격, Cross Site Request Forgeries, Session Fixation 인증의 취약성, 인가에 대한 취약성

출력에 기인하는 취약성은 모두 인젝션 계통의 취약성으로 구분된다. 데이터는 싱글 쿼테이션, 더블 쿼테이션, 구분자 등 미리 결정된 문법 구조로 이루어지는데 이를 이용하여 인젝션을 한다.

SQL 인젝션의 경우,

```sql
SELECT * FROM users WHere id='$id'
```

어플리케이션의 취약성을 이용하여 $id 변수에 아래와 같은 임의의 문자열을 준다.

```sql
'; DELETE FROM user --
```

그러면 SQL은 다음과 같이 된다.

```sql
SELECT * FROM users WHERE id='';DELETE FROM users --'
```

싱글쿼테이션과 세미콜론으로 첫 번째 SQL 문장을 끝내고 DELETE 문장을 실행하여 user의 데이터를 삭제한다.

이와 같이 인젝션 계통의 취약성은 미리 결정된 문법 구조를 활용한다.

| 취약성 명칭           | 인터페이스      | 악용 수단                   | 데이터의 끝 |
| --------------------- | --------------- | --------------------------- | ----------- |
| 크로스사이트 스크립팅 | HTML            | JavaScript 등의 입력        | < " 등      |
| HTTTP 헤더 인젝션     | HTTL            | HTTP Response Header 입력   | 개행        |
| SQL 인젝션            | SQL             | SQL 명령의 입력             | ' 등        |
| OS 커멘드 인젝션      | Shell Script    | 커멘드 입력                 | ; \| 등     |
| 메일 헤더 인젝션      | sendmail 커멘드 | 메일 헤더, 본문의 입력 변경 | 개행        |



웹 어플리케이션의 입력 부분에서 입력의 문자 인코딩 검증과 변환 입력값의 체크를 해야한다.

- 입력값 검증은 어플리케이션 사양을 기반
- 문자 인코딩 검증
- 제어 문자를 포함한 문자 종류 검증
- 문자수 검증

실시는 다음 순서로 한다.

1. 설계 단계에서 각 파라미터의 문자 종류 및 되대 문자 수를 사양에서 결정
2. 설계 단계에서 입력값 검증의 구현 방침을 결정
3. 개발 단계에서는 사양에 따른 입력값 검증을 구현

XSS 취약성이 생기는 원인은 HTML 생성시에 HTML의 문법상 특별한 의미를 갖는 특수기호(메타문자)를 바르게 다루지 않는 데 원이이 있고, 그로 인해 개발자가 의도하지 않은 형태로 HTML이나 JavaScript가 변형된 현상이 XSS이다.

메타 문자가 가진 특별한 의미를 없애고 문자 그대로 다루기 위해서는 Escape 처리를 해야하고 HTML의 Escape은 Xss를 없애기 위해 매우 중요하다.

#### XSS에 대한 대책

- HTML의 요소 내용 Escape
- 속성 값 Escape하고 더블 쿼테이션으로 묶는다.
- HTTP Response에 문자 인코딩 명시
- 입력값 검증 (영문자, 숫자만 입력 가능 등)
- 쿠키에 HttopOnly 속성을 부여
  - JavaScript에서 쿠키를 읽는 것을 금지

#### SQL 호출에 따른 취약성

SQL 인젝션은 SQL 호출 방법에 취약서이 있는 경우에 발생한다. SQL 인젝션에 대한 확실한 대책은 정적 Placeholder를 이용해서 SQL을 호출하는 것이다.

- 정적, 동적 Placeholder 사용
- 자세한 에러 메시지 표시 x
- 입력값에 대한 타당성 검증
- DB 권한 설정

#### 중요한 처리를할 때 생기는 취약성

- 크로스 사이트 요청 위조(Cross-Site Request Forgeries):  사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격이다.

##### CSRF 취약성이 생기는 원인

- form 요소의 action  속성에는 어떤 도메인 URL이라도 지정할 수 있다.
- 쿠키에 보존된 세션 ID는 타겟이 되는 사이트에 자동으로 전송된다.

##### CSRF 대책

- CSRF 대책이 필요한 페이지 선별

  - 개발 프로세스
    1. 요건 정의 단계에서 기능 리스트를 작성하여, CSRF 대책이 필요한 기능을 체크
    2. 기본 설계 단계에서 화면 이동에 관한 그림을 작성하여, CSRF 대책이 필요한 페이지를 체크
    3. 개발 단계에서 CSRF 대책을 구현

- Request인지를 구별할 수 있도록 프로그래밍한다.

  - 비밀 정보(토큰)을 심는다.

  ```jsp
  <!-- 로그인시,또는 작업화면 요청시 CSRF 토큰을 생성하여 세션에 저장 -->
  session.setAttribute("CSRF_TOKEN", UUID, randomUUID().toString())
  
  <form action="test.jsp" method="POST">
      <!-- CSRF 토큰을 셋팅하여 전송 -->
      <input type="hidden" name="_csrf" value="${CSRF_TOKEN}">
  </form>
  ```

  ```java
  String param = request.getParameter("_csrf");
  
  // 세션에 저장된 토큰 값과 일치하는지 검증
  if(request.getSession().getAttribute("CSRF_TOKEN").equals(param)){
      return true;
  }else{
      return false;
  }
  ```

  - Referer 검증
  - 패스워드 재입력
    - 정상적인 Request와 CSRF 공격에 의한 Request에서는 Referer 필드의 내용이 다르다.

#### 세션의 취약성

- 세션 생성 방법의 문제(추측 가능한 세션 ID를 사용)
- 세션 ID를 쿠키에 보관하지 않고 URL에 포함하는 경우
- 세션 ID의 고정화
  - 로그인시에 세션 ID를 변경하여 로그인 후의 세션 ID를 공격자가 알지 못하도록 한다.

- 쿠키 몬스터 문제가 있는 브라우저를 사용하는 경우

로그인 전의 세션 ID 고정화 공격의 대책

- 로그인 전 세션 변수에는 비밀 정보를 담지 않는다.
- URL 포함 세션 ID를 사용하지 않는다.
- 지역형 도메인을 사용하지 않는다.

세션의 취약성에 대한 대책으로 세션 관리 기능을 직접 구현하지 않고 개발 툴을 사용해야한다. 쿠키에 세션 ID를 보존하고 인증 성공시에 세션 ID를 변경하며 인증 전에는 세션 변수에 비밀 정보를 보존하지 않아야 한다.

세션 ID의 변경이 불가능한 경우는 토큰에 의한 방법을 사용한다. 토큰을 생성하고 쿠키와 세션 변수에 기억하고, 인증 확인시에 쿠키에 있는 토큰과 세션 변수에 토큰 값을 비교하여 같으면 인증되었다고 인식한다.

#### 쿠키에 관한 취약성

쿠키는 세션 ID의 보관 장소로 이용해야하고 데이터 자체를 쿠키에 보존하는 것은 좋지 않다.

쿠키는 HTTPS의 경우에만 브라우저에서 서버로 전송된다. 하지만 HTTPS 통신을 이용하고 있어도, Secure 속성이 없는 쿠키는 암호화되지 않은 데이터로 전송되는 경우가 있다.

Java의 경우 WEB-INF/web.xml에서 설정

```xml
<session-config>
	<cookie-config>
		<secure>true</secure>
	</cookie-config>
</session-config>
```

<strong>쿠키에 secure 속성을 설정할 수 없는 어플리케이션</strong>

HTTP와 HTTPS가 혼합해서 사용하는 웹 어플리켕션의 경우, 세션 ID를 보존하는 쿠키에 secure 속성을 설정하면 곤란하다. 세션 ID 쿠키에 secure 속성을 설정하면 HTTP 페이지에서는 세션 ID 쿠키를 받을 수 없기 때문이다. 이런 경우에는 토큰을 이용한 방법을 사용할 수 있다.

<strong>토큰을 이용한 방법</strong>

큰을 생성하고 쿠키와 세션 변수에 기억하고, 인증 확인시에 쿠키에 있는 토큰과 세션 변수에 토큰 값을 비교하여 같으면 인증되었다고 인식한다.토큰은 서버와 브라우저 쌍방향으로 확실히 암호화되어야 한다.

#### 파일 접근에 발생하는 문제

웹 어플리케이션에서 디렉토리를 파라미터로 지정하는 경우 다음과 같은 공격이 가능하다.

- 웹 서버 안의 파일에 대한 부적절한 접근(디렉토리 트레버셜)
- OS 커멘드의 호출(OS 커맨드 인젝션)

디렉토리 트레버셜은 URL로 스크립트를 실행하여 공격하여 OS의 설정파일을 열 수 있다.

- '%00'은 널바이트

```html
http://example.co/example.jsp?template=../../../etc/hosts%00
```

디렉토리 트레버셜 취약성을 제거하기 위한 방법

- 외부로부터 파일명을 지정할 수 없게 한다.
- 파일명에 디렉토리명이 포함되지 않도록 한다.
- 파일명을 영어/숫자로 제한한다.

#### OS 커멘드를 호출할 때 발생하는 취약성

개발 언어는 대부분 쉘을 이용하여 OS 커멘드를 호출하는 기능을 제공하고 있는데 이를 이용하여 의도하지 않는 OS 커맨드를 실행하는 경우를 OS 커맨드 인젝션 취약성이라 한다.

- 쉘 호출 기능이 있는 함수를 가능한 사용하지 않는다.
- 쉘 호출 기능이 있는 함수에는 외부로부터 파라미터를 전달받지 않는다.
- OS 커맨드에 전달하는 파라미터를 안전한 함수를 사용하여 이스케이프 한다.
- 파라미터의 검증
- 어플리케이션 실행 권한의 축소
- 웹 서버의 OS나 미들웨어 패치

#### 파일 업로드할 때 발생하는 취약성

파일 업로드할 때 업로드 파일에 바이러스를 심거나 스크립트를 포함한 파일을 업로드 후 실행하게 하여 공격할 수 있다.

이미지 데이터 안에 HTML 태그가 포함되어 있으면 조건에 따라 브라우저가 HTML 파일로 인식하여 JavaScript를 실행하는 경우가 있다. 이를 활용한 파일 다운로드에 의한 크로스 사이트 스크립팅을 막기 위한 대책은 아래와 같다

- 파일 Content-Type을 올바르게 설정
- 이미지의 확장자와 이미지의 내용(매직 바이트)이 맞는지 확인
- 다운로드하려는 파일은 response header로 "Content-Disposition attachment"를 지정
